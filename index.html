<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Isnad Analyzer (Browser MVP)</title>
  <style>
    :root { --bg:#0b1220; --card:#111b2e; --muted:#8aa0c7; --ok:#2dd4bf; --bad:#fb7185; --warn:#fbbf24; --text:#e8f0ff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: linear-gradient(180deg, #071024, #0b1220 40%, #070c16); color: var(--text); }
    .wrap { max-width: 1000px; margin: 24px auto; padding: 0 16px 60px; }
    .header { display:flex; gap:14px; align-items:center; margin-bottom:16px; }
    .badge { display:inline-flex; align-items:center; justify-content:center; width:44px; height:44px; border-radius:14px; background:#0f2a2a; border:1px solid rgba(45,212,191,.25); color:var(--ok); font-weight:900; }
    h1 { margin:0; font-size: 20px; letter-spacing:.08em; text-transform:uppercase; }
    p.sub { margin:4px 0 0; color: var(--muted); font-size: 12px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 980px){ .grid { grid-template-columns: 1.1fr .9fr; } }
    .card { background: rgba(17,27,46,.9); border: 1px solid rgba(138,160,199,.15); border-radius: 18px; padding: 14px; box-shadow: 0 18px 50px rgba(0,0,0,.35); }
    label { font-size: 11px; text-transform: uppercase; letter-spacing:.12em; color: var(--muted); font-weight: 800; display:block; margin: 10px 0 6px; }
    input[type="text"], select, textarea {
      width: 100%; box-sizing: border-box; padding: 10px 12px; border-radius: 12px;
      border: 1px solid rgba(138,160,199,.2); background: rgba(5,10,20,.6); color: var(--text);
      outline: none;
    }
    textarea { min-height: 150px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; line-height: 1.45; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .btn {
      cursor:pointer; border:0; border-radius: 14px; padding: 10px 12px; font-weight: 900;
      letter-spacing:.08em; text-transform: uppercase; font-size: 11px;
      background: #10b981; color: #072113;
    }
    .btn.secondary { background: rgba(138,160,199,.12); color: var(--text); border: 1px solid rgba(138,160,199,.18); }
    .btn.danger { background: rgba(251,113,133,.15); color: #ffd0d8; border: 1px solid rgba(251,113,133,.25); }
    .btn:disabled { opacity: .55; cursor: not-allowed; }
    .hint { color: var(--muted); font-size: 12px; margin-top: 8px; line-height: 1.4; }
    .status { margin-top: 10px; padding: 10px 12px; border-radius: 14px; border: 1px solid rgba(138,160,199,.18); background: rgba(5,10,20,.45); color: var(--muted); font-size: 12px; }
    .status.ok { border-color: rgba(45,212,191,.25); color: #b9fff4; background: rgba(45,212,191,.08); }
    .status.bad { border-color: rgba(251,113,133,.25); color: #ffd0d8; background: rgba(251,113,133,.07); }
    .status.warn { border-color: rgba(251,191,36,.25); color: #ffe7b0; background: rgba(251,191,36,.07); }
    img.preview { width: 100%; max-height: 420px; object-fit: contain; border-radius: 14px; border: 1px solid rgba(138,160,199,.15); background: rgba(0,0,0,.25); }
    pre { white-space: pre-wrap; word-break: break-word; margin: 0; font-size: 12px; line-height: 1.45; color: #dbe7ff; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(138,160,199,.18); background: rgba(138,160,199,.08); color: var(--muted); font-size: 12px; }
    .tag { font-weight: 900; letter-spacing:.1em; text-transform:uppercase; font-size: 10px; padding: 4px 8px; border-radius: 999px; }
    .tag.ok { background: rgba(45,212,191,.15); color: #b9fff4; border: 1px solid rgba(45,212,191,.2); }
    .tag.mid { background: rgba(251,191,36,.15); color: #ffe7b0; border: 1px solid rgba(251,191,36,.2); }
    .tag.bad { background: rgba(251,113,133,.15); color: #ffd0d8; border: 1px solid rgba(251,113,133,.2); }
    .tag.unk { background: rgba(138,160,199,.15); color: #d7e5ff; border: 1px solid rgba(138,160,199,.2); }
    .table { display:grid; gap: 10px; }
    .ncard { padding: 10px 12px; border-radius: 14px; border: 1px solid rgba(138,160,199,.15); background: rgba(5,10,20,.35); }
    .nhead { display:flex; justify-content:space-between; align-items:flex-start; gap: 8px; }
    .nname { font-weight: 900; color: #eef4ff; }
    .nnotes { color: var(--muted); font-size: 12px; margin-top: 6px; }
    .small { font-size: 11px; color: var(--muted); }
    .footer { margin-top: 16px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="badge">ﻋ</div>
      <div>
        <h1>Isnad Analyzer — Browser MVP</h1>
        <p class="sub">2-step flow: (A) Image → OCR text, (B) OCR text → JSON. Local demo rijāl lookup included.</p>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <label>Gemini API Key (for local testing only)</label>
        <input id="apiKey" type="text" placeholder="AIza..." autocomplete="off" />

        <div class="row" style="margin-top:10px;">
          <div style="flex:1; min-width: 240px;">
            <label>Model</label>
            <select id="model">
              <option value="gemini-2.5-flash-preview-09-2025">gemini-2.5-flash-preview-09-2025</option>
              <option value="gemini-1.5-flash">gemini-1.5-flash</option>
              <option value="gemini-1.5-pro">gemini-1.5-pro</option>
            </select>
          </div>
          <div style="flex:1; min-width: 240px;">
            <label>Upload image (PNG/JPG/WEBP)</label>
            <input id="file" type="file" accept="image/png,image/jpeg,image/webp" />
          </div>
        </div>

        <div style="margin-top:12px;">
          <img id="preview" class="preview" alt="preview" style="display:none;" />
        </div>

        <div class="row" style="margin-top:12px;">
          <button id="btnOcr" class="btn" disabled>1) OCR from image</button>
          <button id="btnAnalyze" class="btn secondary" disabled>2) Analyze OCR text</button>
          <button id="btnReset" class="btn danger">Reset</button>
        </div>

        <div class="hint">
          For best results: crop tightly to the text (remove phone UI), avoid heavy highlights, use higher-res scans.
        </div>

        <div id="status" class="status">Waiting for input.</div>

        <label style="margin-top:12px;">OCR Text (editable)</label>
        <textarea id="ocrText" placeholder="After OCR step, the extracted Arabic text appears here (edit it if needed)."></textarea>

        <label style="margin-top:12px;">Raw model output (debug)</label>
        <textarea id="rawOut" placeholder="If JSON parsing fails, you'll see the raw model output here."></textarea>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div class="pill"><span class="tag ok">MVP</span> Structured output</div>
          <div class="small">No backend • Local test</div>
        </div>

        <label style="margin-top:12px;">Parsed Result (JSON)</label>
        <div class="card" style="background: rgba(5,10,20,.35);">
          <pre id="parsedJson">{}</pre>
        </div>

        <label style="margin-top:12px;">Narrators (demo rijāl lookup)</label>
        <div id="narrators" class="table"></div>

        <div class="footer">
          ⚠️ Do not publish this with a real API key in the browser. Move requests to a server route before deploying.
        </div>
      </div>
    </div>
  </div>

<script>
  // --------- Small demo rijāl dataset (expand later) ----------
  const rijalDemo = [
    { name: "مالك بن أنس", status: "إمام ثقة", notes: "إمام دار الهجرة. من أئمة الحديث.", sources: "تهذيب الكمال؛ سير أعلام النبلاء" },
    { name: "نافع مولى ابن عمر", status: "ثقة ثبت", notes: "من أوثق الناس في ابن عمر.", sources: "تهذيب التهذيب؛ تقريب التهذيب" },
    { name: "عبد الله بن عمر", status: "صحابي", notes: "الصحابة عدول.", sources: "إجماع أهل السنة" },
    // demo-only placeholders
    { name: "حبيب بن أبي حبيب", status: "ضعيف جدًا (تجريبي)", notes: "مدخل تجريبي فقط. لا تُنزّل به حكمًا شرعيًا دون مصادر رجال محققة.", sources: "—" },
  ];

  const $ = (id) => document.getElementById(id);

  let imageBase64 = null;
  let imageMime = null;
  let previewUrl = null;

  function setStatus(msg, kind="") {
    const el = $("status");
    el.className = "status" + (kind ? " " + kind : "");
    el.textContent = msg;
  }

  function normalizeArabic(s) {
    return (s || "")
      .replace(/[ًٌٍَُِّْـ]/g, "")
      .replace(/[أإآ]/g, "ا")
      .replace(/ى/g, "ي")
      .replace(/ة/g, "ه")
      .replace(/\s+/g, " ")
      .trim();
  }

  function statusTagClass(status) {
    const t = (status || "").toLowerCase();
    if (/(thiqa|ثقة|ثبت|إمام)/.test(t)) return "ok";
    if (/(صدوق|حسن|مقبول|لا باس|لين)/.test(t)) return "mid";
    if (/(ضعيف|متروك|كذاب|مجهول)/.test(t)) return "bad";
    return "unk";
  }

  function extractFirstJsonObject(s) {
    const start = s.indexOf("{");
    const end = s.lastIndexOf("}");
    if (start === -1 || end === -1 || end <= start) return null;
    return s.slice(start, end + 1);
  }

  async function geminiGenerate({ apiKey, model, parts, responseMimeType }) {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`;

    const payload = {
      contents: [{ parts }],
      generationConfig: responseMimeType ? { responseMimeType } : undefined
    };

    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    if (!res.ok) {
      const msg = data?.error?.message || `API error ${res.status}`;
      throw new Error(msg);
    }
    const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!text) throw new Error("No text returned from model.");
    return text;
  }

  function renderNarrators(parsed) {
    const box = $("narrators");
    box.innerHTML = "";

    const all = [];
    (parsed?.isnad_chains || []).forEach(ch => (ch?.narrators || []).forEach(n => all.push(n)));

    if (!all.length) {
      box.innerHTML = `<div class="small">No narrators extracted (or OCR unclear).</div>`;
      return;
    }

    for (const rawName of all) {
      const q = normalizeArabic(rawName);
      const hit = rijalDemo.find(r => normalizeArabic(r.name) === q);

      const status = hit ? hit.status : "غير موجود في قاعدة البيانات (MVP)";
      const notes = hit ? hit.notes : "لم يتم العثور على مطابق. القاعدة صغيرة أو الاسم مختلف الرسم.";
      const sources = hit ? hit.sources : "";

      const tag = statusTagClass(status);

      const div = document.createElement("div");
      div.className = "ncard";
      div.innerHTML = `
        <div class="nhead">
          <div class="nname">${rawName}</div>
          <span class="tag ${tag}">${status}</span>
        </div>
        <div class="nnotes">${notes}</div>
        ${sources ? `<div class="small" style="margin-top:6px;">Sources: ${sources}</div>` : ""}
      `;
      box.appendChild(div);
    }
  }

  function setParsedJson(obj) {
    $("parsedJson").textContent = JSON.stringify(obj, null, 2);
    renderNarrators(obj);
  }

  // ---------- Events ----------
  $("file").addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (!["image/png","image/jpeg","image/webp"].includes(file.type)) {
      setStatus("Only PNG/JPEG/WEBP supported.", "bad");
      return;
    }
    if (file.size > 10 * 1024 * 1024) {
      setStatus("Image too large. Max 10MB.", "bad");
      return;
    }

    imageMime = file.type;

    if (previewUrl) URL.revokeObjectURL(previewUrl);
    previewUrl = URL.createObjectURL(file);
    const img = $("preview");
    img.src = previewUrl;
    img.style.display = "block";

    // Read base64
    const reader = new FileReader();
    reader.onloadend = () => {
      const s = String(reader.result || "");
      imageBase64 = s.split(",")[1] || null;
      $("btnOcr").disabled = !imageBase64;
      setStatus(imageBase64 ? "Image loaded. Run OCR." : "Failed to read image.", imageBase64 ? "ok" : "bad");
    };
    reader.readAsDataURL(file);

    $("ocrText").value = "";
    $("rawOut").value = "";
    setParsedJson({});
    $("btnAnalyze").disabled = true;
  });

  $("btnReset").addEventListener("click", () => {
    imageBase64 = null;
    imageMime = null;
    if (previewUrl) URL.revokeObjectURL(previewUrl);
    previewUrl = null;

    $("file").value = "";
    $("preview").style.display = "none";
    $("preview").src = "";
    $("ocrText").value = "";
    $("rawOut").value = "";
    setParsedJson({});
    $("btnOcr").disabled = true;
    $("btnAnalyze").disabled = true;
    setStatus("Reset. Waiting for input.");
  });

  $("btnOcr").addEventListener("click", async () => {
    const apiKey = $("apiKey").value.trim();
    const model = $("model").value;

    if (!apiKey) return setStatus("Paste your Gemini API key first.", "bad");
    if (!imageBase64) return setStatus("Upload an image first.", "bad");

    $("btnOcr").disabled = true;
    $("btnAnalyze").disabled = true;
    setStatus("Running OCR (image → text)...", "warn");

    const ocrPrompt = `
Extract the Arabic text from this image as accurately as possible.
- Output ONLY the extracted text (Arabic).
- Preserve line breaks.
- Include footnotes if visible.
- Do NOT add explanations. Do NOT translate. Do NOT summarize.
If unreadable, output the best effort and mark unclear segments with [غير واضح].
`.trim();

    try {
      const text = await geminiGenerate({
        apiKey,
        model,
        parts: [
          { text: ocrPrompt },
          { inlineData: { mimeType: imageMime || "image/png", data: imageBase64 } }
        ]
      });

      $("ocrText").value = text.trim();
      $("rawOut").value = "";
      setStatus("OCR complete. Review/edit the text, then run analysis.", "ok");
      $("btnAnalyze").disabled = false;
    } catch (err) {
      $("rawOut").value = String(err?.message || err);
      setStatus("OCR failed. Try cropping tighter or using a clearer scan.", "bad");
    } finally {
      $("btnOcr").disabled = false;
    }
  });

  $("btnAnalyze").addEventListener("click", async () => {
    const apiKey = $("apiKey").value.trim();
    const model = $("model").value;
    const ocrText = $("ocrText").value.trim();

    if (!apiKey) return setStatus("Paste your Gemini API key first.", "bad");
    if (!ocrText) return setStatus("OCR text is empty. Run OCR first.", "bad");

    $("btnAnalyze").disabled = true;
    setStatus("Analyzing OCR text (text → structured JSON)...", "warn");

    const analysisPrompt = `
You are extracting structured data from Arabic OCR text from a scanned Islamic book page.

Return ONLY valid JSON with EXACT keys (no extra keys):
{
  "transcription": "Cleaned Arabic text (same meaning, fix obvious OCR spacing only)",
  "source_candidates": [{"book":"", "author":"", "confidence": 0, "evidence":""}],
  "isnad_chains": [{"raw_chain":"", "narrators":["...","..."]}],
  "matn_summary": "1-3 sentence English summary of the main text",
  "warnings": ["..."],
  "manhaj_verdict": "If it contains a weak chain, state why. If OCR uncertainty is high, say so. Do not invent."
}

Rules:
- No markdown. No backticks.
- Do NOT invent narrators or sources. If unsure, use empty strings/arrays and add a warning.
- Extract narrator names exactly as they appear (keep Arabic).
- If footnotes mention a narrator evaluation, include it as a warning (quote short phrases only).
`.trim();

    try {
      const raw = await geminiGenerate({
        apiKey,
        model,
        responseMimeType: "application/json",
        parts: [{ text: analysisPrompt + "\n\nOCR_TEXT:\n" + ocrText }]
      });

      $("rawOut").value = raw;

      const cleaned = raw.replace(/```json|```/g, "").trim();
      let jsonStr = cleaned;

      try {
        JSON.parse(jsonStr);
      } catch {
        const extracted = extractFirstJsonObject(cleaned);
        if (!extracted) throw new Error("Model did not return valid JSON.");
        JSON.parse(extracted);
        jsonStr = extracted;
      }

      const parsed = JSON.parse(jsonStr);
      setParsedJson(parsed);

      const warnCount = (parsed?.warnings || []).length;
      setStatus(
        warnCount ? `Analysis complete with warnings (${warnCount}).` : "Analysis complete.",
        warnCount ? "warn" : "ok"
      );
    } catch (err) {
      setStatus("Analysis failed. The model likely returned invalid JSON. Check Raw output.", "bad");
    } finally {
      $("btnAnalyze").disabled = false;
    }
  });

  // Initialize
  setParsedJson({});
</script>
</body>
</html>
